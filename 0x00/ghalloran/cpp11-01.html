<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
     <link rel = "stylesheet" type = "text/css" href = "../../style.css" />
</head>
<body>
<h1 id="learning-c11-part-1">Learning C++11 (Part 1)</h1>
<h2 id="background">Background</h2>
<p>As a long time C/C++ programmer I thought it was time to delve into some of the newer features of C++ now that Visual Studio 2015 offers full support and the team is making wider use. The purpose is to be able to understand code that is already written and to be more effective in my own code.</p>
<h2 id="auto-keyword-or-type-inference"><em>auto</em> keyword (or type inference)</h2>
<p>The first thing I wanted to understand is the <em>auto</em> keyword. Very simply, using <em>auto</em> adds the ability to infer the type of a variable. I immediately gravitated towards a couple of use cases.</p>
<p><strong>Old C++</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="cf">for</span> (<span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;::const_iterator itr = v.cbegin(); itr != v.cend(); ++itr)</code></pre></div>
<p><strong>C++11</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  <span class="cf">for</span> (_auto_ itr = v.cbegin(); itr != v.cend(); ++itr)</code></pre></div>
<p>Using <em>auto</em> to infer the verbose syntax of iterators or other templated code increases code readability.</p>
<p><strong>Old C++</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  SomeNamespace::MyClass::SomeEnumType rv = myclass.someFunction();</code></pre></div>
<p><strong>C++11</strong></p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">  _auto_ rv = myclass.someFunction();</code></pre></div>
<p>Use can also use <em>auto</em> to infer the return type of a function. Especially when it's not useful to see the return type spelled out. Simplifying the code with no loss of clarity. This also comes in handy if the return type is some kind of integer but you don't really care what size or sign it is (like from some kind of size() function). But be careful if you do care about size or sign (like when you're bit twiddling).</p>
<p>Best advice I was offered was to use <em>auto</em> as much as possible and then see where things break or if code becomes harder to read. The <em>auto</em> keyword replaces code that already works so use it as much as you're comfortable with.</p>
<p>-- Garner Halloran (Engine Programmer)</p>
</body>
</html>
